# bool
+ bool   0/1   0-假，非0为真
+ 占用字节数（bool：1，BOOL：4）

# const
+ const 修饰常量
+ 编译器在编译的时候检查
const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。
非 const 类型可以转换为 const 类型，将 const 类型的数据交给了非 const 类型的变量则尽可能不要。

```c++
    int a=10;
    int *p=&a;

    count<< &a <<end1;//变量地址
    count<< p <<end1;//变量地址
    count<< &p <<end1;//指针地址  
    count<< *p <<end1;//变量的值

    const int *p=&a// 该指针指向的内容不能修改，但指针值可以
    int const *p=&a;// 该指针指向的内容不能修改，但指针值可以
    int *const p=&a;//该指针的地址不能修改，但指针指向的内容可以
    const int *const p=&a;//值不能修改，地址也不能修改
```
# 随机数
一般使用 `<stdlib.h>` 头文件中的 `rand()` 函数来生成随机数,用法为：`int rand (void)`;通过 `void srand (unsigned int seed)` 函数来重新“播种”，这样种子就会发生改变,使用 `<time.h>` 头文件中的 `srand((unsigned)time(NULL))` 函数即可得到当前的时间（精确到秒），作为srand的参数
通过取模来获得一定范围的随机数


# 默认参数
```c++
#define test1(m) Test(m,1,2)
int Test(int n1, int n2, int n3) {return 0;}
int main()
{
	test1(0);
	return 0;
}
```
或者使用默认参数
```c++
int test (int n1,int n2=3,int n3=2){return 0;}
int main()
{
	test(0,1);
	return 0;
}
```
传入的参数会覆盖掉默认参数
默认参数可以在申明的地方也可以在定义的地方，不能同时出现

# 内联函数 inline
节省花费在函数调用机制上的时间在函数内容很少时，在编译时进行替换
**要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的**（用户没有必要、也不应该知道函数是否需要内联）
适合短小的、频繁调用的函数声明为内联函数。

# 内存分配
一个由C/C++编译程序占用内存分为以下几个部分
1. 栈区（stack）― 由编译器自动分配释放 ，存放**用以存放程序局部变量，临时变量，函数参数，返回地址等**等。其操作方式类似于数据结构中栈，这块区域中变量分配和释放由系统自动进行。不需要用户参与。 **栈是线程独立的，每个线程都有自己的栈。**
2. 堆区（heap） ― 一般由程序员malloc或new申请分配，自己负责在何时用free或delete释放内存。 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中堆是两回事，分配方式倒是类似于链表，动态内存生存期由我们决定，使用非常灵活，但问题也最多。
3. 全局区（静态区）（static）―，**全局变量和静态变量**存储是放在一块，初始化全局变量和静态变量在一块区域， 未初始化全局变量和未初始化静态变量在相邻另一块区域。 - 程序结束后由系统释放。-->分别是data区，bbs区 
4. 文字常量区 ―常量字符串就是放在这里。 程序结束后由系统释放-->coment区
5. 程序代码区―存放函数体二进制代码。-->code(text)区

# 类成员访问权限
C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。
+ public意味着随后的定义对所有人都适用；
+ private意味着除了该类型的创建者和该类型的内部成员函数之外，任何人都无法访问这些定义；
+ protected是继承的类可以访问protected的成员，但不能访问private的成员。
成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，通过 public 属性的成员函数`set变量名()`为成员变量赋值，`get变量名()`读值,或者通过构造函数来赋值，但只能用一次。
如果既不写 private 也不写 public，就**默认为 private**。
# 对象的内存模型
+ 类是创建对象的模板，不占用内存空间，不存在于编译后的可执行文件中；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。
+ 编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。
![](../photo/c++_memory.png)
+ sizeof() 求得该类型的大小时只计算了成员变量的大小，并没有把成员函数也包含在内。
# 构造函数初始化列表
C++类中成员变量的初始化有两种方式：
+ 构造函数初始化列表
+ 构造函数体内赋值
对于初始化列表：
1. 成员变量的赋值顺序由它们在类中的声明顺序决定，而不是由传参决定：
```c++
Demo::Demo(int b): m_b(b), m_a(m_b){ }
```
等价于
```c++
Demo::Demo(int b): m_b(b), m_a(m_b){
    m_a = m_b;
    m_b = b;
}
```
2. 初始化 const 成员变量的唯一方法就是使用初始化列表
```c++
class VLA{
private:
    const int m_len;
    int *m_arr;
public:
    VLA(int len);
};

//必须使用初始化列表来初始化 m_len
VLA::VLA(int len): m_len(len){
    m_arr = new int[len];
}
```
# 析构函数
