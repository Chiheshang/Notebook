# 锁

## 互斥锁和自旋锁

互斥锁和自旋锁是最底层的两种锁。当线程A获取到锁后，线程B再去获取锁，自旋锁是线程B循环的去尝试获取锁，直到获取成功为止；互斥锁是线程B放弃获取锁，在锁空闲时，等待被唤醒。

互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，存在一定的性能开销。
  (1)当线程加锁失败，内核会把线程的状态由“运行”设置为“睡眠”，让出cpu。
  (2)当锁空闲时，内核唤醒线程，状态设置为“就绪”，放入ready队列。
而自旋锁会自用户态由应用程序完成，不涉及用户态到内核态的转化，没有线程上下文切换，性能相对较好。自旋锁加锁过程：
  (1)查看锁的状态
  (2)锁空闲，获取锁，否则执行(1)

自旋锁会利用cpu一直工作直到获取到锁，中间不会释放cpu，但如果被锁住的代码执行时间较长，反而性能较差。

## 读写锁

读写锁由读锁和写锁组成。读锁又称为共享锁，S锁，写锁又称为排它锁、X锁，在mysql的事务中大量使用。写锁是独占锁，一旦线程获取写锁，其他线程不能获取写锁和读锁。读锁是共享锁，当线程获取读锁，其他线程可以获取读锁不能获取写锁。因为并发数据读取并不会改变共享数据导致数据不一致。读写锁把对共享资源的读操作和写操作分别加锁控制，能够提高读线程的并发性，适用于读多写少的场景。

## 读优先锁、写优先锁

读优先锁：线程A获取了读锁，线程B想获取写锁，此时会被阻塞，线程c可以继续获取读锁，直到A和c释放锁，线程B才可以获取写锁。

写优先锁：线程A获取了读锁，线程B想获取写锁，此时会被阻塞，后面获取读锁都会失败，线程A释放锁，线程B可以获取写锁，其他获取读锁的线程阻塞。

上面两种锁都会造成【饥饿】现象，为解决这种问题，可以增加一个队列，把获取锁的线程（不管是写线程还是读线程）按照先进先出的方式排队，每次从队列中取出一个线程获取锁，这种获取锁的方式是公平的。

## 乐观锁和悲观锁

乐观锁是先修改共享资源，再用历史数据和当前数据比对验证这段时间共享数据有没有被修改，如果没有被修改，那么更新数据，如果有其他线程更新了共享资源，需要重新获取数据，再更新，验证，循环往复的重试，直到更新成功。

悲观锁是在访问共享资源之前统统加锁。互斥锁、自旋锁都是悲观锁的实现。

乐观锁其实全程没有加锁，也叫无锁编程，所以针对读多写少的场景，并发性能较高。

